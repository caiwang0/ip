[1mdiff --git a/src/main/java/chip/command/Parser.java b/src/main/java/chip/command/Parser.java[m
[1mindex 7844670..59e5e24 100644[m
[1m--- a/src/main/java/chip/command/Parser.java[m
[1m+++ b/src/main/java/chip/command/Parser.java[m
[36m@@ -58,8 +58,15 @@[m [mpublic class Parser {[m
      * @throws ChipException if the command is invalid or cannot be executed[m
      */[m
     public static void parse(String fullCommand, TaskList tasks, Ui ui, Storage storage) throws ChipException {[m
[32m+[m[32m        assert fullCommand != null : "Command cannot be null";[m
[32m+[m[32m        assert tasks != null : "TaskList cannot be null";[m
[32m+[m[32m        assert ui != null : "Ui cannot be null";[m
[32m+[m[32m        assert storage != null : "Storage cannot be null";[m
[32m+[m[41m        [m
         String[] parts = fullCommand.split(COMMAND_SEPARATOR, COMMAND_PART_LIMIT);[m
[32m+[m[32m        assert parts.length > 0 : "Command parts should have at least one element";[m
         Command action = Command.valueOf(parts[0].toUpperCase());[m
[32m+[m[32m        assert action != null : "Command should be valid after parsing";[m
 [m
         switch (action) {[m
         case LIST:[m
[36m@@ -96,61 +103,79 @@[m [mpublic class Parser {[m
      * @param ui the user interface for showing messages[m
      */[m
     private static void showTaskList(TaskList tasks, Ui ui) {[m
[32m+[m[32m        assert tasks != null : "TaskList cannot be null";[m
[32m+[m[32m        assert ui != null : "Ui cannot be null";[m
[32m+[m[41m        [m
         ui.showMessage(MESSAGE_LIST_HEADER);[m
         for (int i = 0; i < tasks.size(); i++) {[m
[31m-            ui.showMessage(tasks.formatTaskForDisplay(i, tasks.getTask(i)));[m
[32m+[m[32m            Task task = tasks.getTask(i);[m
[32m+[m[32m            assert task != null : "Task at index " + i + " should not be null";[m
[32m+[m[32m            ui.showMessage(tasks.formatTaskForDisplay(i, task));[m
         }[m
     }[m
 [m
     /**[m
      * Marks a specified task as completed.[m
[31m-     *[m
[31m-     * @param parts command parts where parts[1] should contain the task number[m
[31m-     * @param tasks the task list containing the task to mark[m
[31m-     * @param ui the user interface for showing messages[m
[31m-     * @param storage the storage component for saving changes[m
[31m-     * @throws ChipException if task number is not specified or invalid[m
      */[m
     private static void markTask(String[] parts, TaskList tasks, Ui ui, Storage storage) throws ChipException {[m
[32m+[m[32m        assert parts != null : "Command parts cannot be null";[m
[32m+[m[32m        assert tasks != null : "TaskList cannot be null";[m
[32m+[m[32m        assert ui != null : "Ui cannot be null";[m
[32m+[m[32m        assert storage != null : "Storage cannot be null";[m
[32m+[m[41m        [m
         validateCommandParts(parts, ERROR_MARK_TASK);[m
         int taskNumber = parseTaskNumber(parts[1]);[m
         Task task = tasks.getTask(taskNumber);[m
[32m+[m[32m        assert task != null : "Retrieved task should not be null";[m
[32m+[m[41m        [m
         task.markAsDone();[m
[32m+[m[32m        assert task.getStatusIcon().equals("X") : "Task should show as done after marking";[m
[32m+[m[41m        [m
         showTaskOperationResult(ui, MESSAGE_TASK_MARKED, task);[m
         storage.save(tasks.getTasks());[m
     }[m
 [m
     /**[m
      * Marks a specified task as not completed.[m
[31m-     *[m
[31m-     * @param parts command parts where parts[1] should contain the task number[m
[31m-     * @param tasks the task list containing the task to unmark[m
[31m-     * @param ui the user interface for showing messages[m
[31m-     * @param storage the storage component for saving changes[m
[31m-     * @throws ChipException if task number is not specified or invalid[m
      */[m
     private static void unmarkTask(String[] parts, TaskList tasks, Ui ui, Storage storage) throws ChipException {[m
[32m+[m[32m        assert parts != null : "Command parts cannot be null";[m
[32m+[m[32m        assert tasks != null : "TaskList cannot be null";[m
[32m+[m[32m        assert ui != null : "Ui cannot be null";[m
[32m+[m[32m        assert storage != null : "Storage cannot be null";[m
[32m+[m[41m        [m
         validateCommandParts(parts, ERROR_UNMARK_TASK);[m
         int taskNumber = parseTaskNumber(parts[1]);[m
         Task task = tasks.getTask(taskNumber);[m
[32m+[m[32m        assert task != null : "Retrieved task should not be null";[m
[32m+[m[41m        [m
         task.markAsNotDone();[m
[32m+[m[32m        assert task.getStatusIcon().equals(" ") : "Task should show as not done after unmarking";[m
[32m+[m[41m        [m
         showTaskOperationResult(ui, MESSAGE_TASK_UNMARKED, task);[m
         storage.save(tasks.getTasks());[m
     }[m
 [m
     /**[m
      * Deletes a specified task from the task list.[m
[31m-     *[m
[31m-     * @param parts command parts where parts[1] should contain the task number[m
[31m-     * @param tasks the task list to delete from[m
[31m-     * @param ui the user interface for showing messages[m
[31m-     * @param storage the storage component for saving changes[m
[31m-     * @throws ChipException if task number is not specified or invalid[m
      */[m
     private static void deleteTask(String[] parts, TaskList tasks, Ui ui, Storage storage) throws ChipException {[m
[32m+[m[32m        assert parts != null : "Command parts cannot be null";[m
[32m+[m[32m        assert tasks != null : "TaskList cannot be null";[m
[32m+[m[32m        assert ui != null : "Ui cannot be null";[m
[32m+[m[32m        assert storage != null : "Storage cannot be null";[m
[32m+[m[41m        [m
         validateCommandParts(parts, ERROR_DELETE_TASK);[m
         int taskNumber = parseTaskNumber(parts[1]);[m
[32m+[m[41m        [m
[32m+[m[32m        int initialSize = tasks.size();[m
[32m+[m[32m        assert taskNumber >= 0 : "Task number should be non-negative after conversion";[m
[32m+[m[32m        assert taskNumber < initialSize : "Task number should be within valid range";[m
[32m+[m[41m        [m
         Task removedTask = tasks.deleteTask(taskNumber);[m
[32m+[m[32m        assert removedTask != null : "Removed task should not be null";[m
[32m+[m[32m        assert tasks.size() == initialSize - 1 : "Task list should be smaller after deletion";[m
[32m+[m[41m        [m
         showTaskOperationResult(ui, MESSAGE_TASK_DELETED, removedTask);[m
         ui.showMessage(String.format(MESSAGE_TASK_COUNT, tasks.size()));[m
         storage.save(tasks.getTasks());[m
[36m@@ -158,85 +183,114 @@[m [mpublic class Parser {[m
 [m
     /**[m
      * Adds a new todo task to the task list.[m
[31m-     *[m
[31m-     * @param parts command parts where parts[1] should contain the task description[m
[31m-     * @param tasks the task list to add to[m
[31m-     * @param ui the user interface for showing messages[m
[31m-     * @param storage the storage component for saving changes[m
[31m-     * @throws ChipException if task description is empty[m
      */[m
     private static void addTodo(String[] parts, TaskList tasks, Ui ui, Storage storage) throws ChipException {[m
[32m+[m[32m        assert parts != null : "Command parts cannot be null";[m
[32m+[m[32m        assert tasks != null : "TaskList cannot be null";[m
[32m+[m[32m        assert ui != null : "Ui cannot be null";[m
[32m+[m[32m        assert storage != null : "Storage cannot be null";[m
[32m+[m[41m        [m
         validateCommandParts(parts, ERROR_TODO_EMPTY);[m
[32m+[m[41m        [m
[32m+[m[32m        int initialSize = tasks.size();[m
         Task newTodo = new Todo(parts[1]);[m
[32m+[m[32m        assert newTodo != null : "Created todo should not be null";[m
[32m+[m[32m        assert newTodo.toString().startsWith("[T]") : "Todo should have correct type indicator";[m
[32m+[m[41m    